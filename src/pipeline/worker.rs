use crate::domain::events::event::Event;
use crate::pipeline::command::PipelineCommand;
use crate::storage::event_store::EventStore;
use std::sync::Arc;
use tokio::sync::mpsc;

pub struct Worker {
    _id: usize,
    store: Arc<dyn EventStore + Send + Sync>,
}

impl Worker {
    pub fn new(_id: usize, store: Arc<dyn EventStore + Send + Sync>) -> Self {
        Self { _id, store }
    }

    pub async fn run(self, mut rx: mpsc::Receiver<PipelineCommand>) {
        while let Some(cmd) = rx.recv().await {
            match cmd {
                PipelineCommand::Append {
                    stream_id,
                    mut events,
                    expected_version,
                    resp_tx,
                } => {
                    let res = self
                        .handle_append(&stream_id, &mut events, expected_version)
                        .await;
                    let _ = resp_tx.send(res);
                }
            }
        }
    }

    async fn handle_append(
        &self,
        stream_id: &str,
        events: &mut Vec<Event>,
        expected_version: i64,
    ) -> Result<bool, String> {
        // 1. Resolve expected version
        let mut current_version_u64 = if expected_version == -1 {
            // "Any" version: Fetch tail to determine next
            let current_events = self
                .store
                .fetch_stream(stream_id)
                .await
                .map_err(|e| e.to_string())?;
            current_events
                .last()
                .map(|e| e.sequence_number)
                .unwrap_or(0)
        } else {
            // Specific version expected
            if expected_version < 0 {
                0
            } else {
                expected_version as u64
            }
        };

        // 2. Prepare events
        for event in events.iter_mut() {
            event.stream_id = stream_id.to_string();
        }

        // 3. Persist Loop
        // Note: This is not atomic batch! Partial failure is possible.
        // To fix this proper, EventStore needs transaction support.
        // But with OCC, we at least won't corrupt data, just stop.
        for event in events.drain(..) {
            match self
                .store
                .append_event(stream_id, event, current_version_u64)
                .await
            {
                Ok(_) => {
                    current_version_u64 += 1;
                }
                Err(e) => {
                    tracing::error!("Failed to append event to stream {}: {}", stream_id, e);
                    // Abort batch
                    return Ok(false);
                }
            }
        }

        Ok(true)
    }
}

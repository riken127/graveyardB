// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: eventstore.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "eventstore";

export interface Event {
  id: string;
  eventType: string;
  payload: Buffer;
  timestamp: number;
}

export interface AppendEventRequest {
  streamId: string;
  events: Event[];
  /**
   * Expected version for optimistic concurrency control.
   * -1 (or omit/0 depending on logic) can represent "any version" or "no check".
   * For specific requirement, explicit version is needed.
   */
  expectedVersion: number;
}

export interface AppendEventResponse {
  success: boolean;
}

export interface GetEventsRequest {
  streamId: string;
}

export interface Schema {
  name: string;
  fields: { [key: string]: Field };
}

export interface Schema_FieldsEntry {
  key: string;
  value?: Field | undefined;
}

export interface Field {
  fieldType?: FieldType | undefined;
  nullable: boolean;
  overridesOnNull: boolean;
  constraints?: FieldConstraints | undefined;
}

export interface FieldConstraints {
  required: boolean;
  /** For numbers */
  minValue?: number | undefined;
  maxValue?:
    | number
    | undefined;
  /** For strings */
  minLength?: number | undefined;
  maxLength?: number | undefined;
  regex?: string | undefined;
}

export interface FieldType {
  primitive?: FieldType_Primitive | undefined;
  enumDef?: FieldType_Enum | undefined;
  subSchema?: Schema | undefined;
  arrayDef?: FieldType_Array | undefined;
}

export enum FieldType_Primitive {
  NUMBER = 0,
  STRING = 1,
  BOOLEAN = 2,
  UNRECOGNIZED = -1,
}

export function fieldType_PrimitiveFromJSON(object: any): FieldType_Primitive {
  switch (object) {
    case 0:
    case "NUMBER":
      return FieldType_Primitive.NUMBER;
    case 1:
    case "STRING":
      return FieldType_Primitive.STRING;
    case 2:
    case "BOOLEAN":
      return FieldType_Primitive.BOOLEAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldType_Primitive.UNRECOGNIZED;
  }
}

export function fieldType_PrimitiveToJSON(object: FieldType_Primitive): string {
  switch (object) {
    case FieldType_Primitive.NUMBER:
      return "NUMBER";
    case FieldType_Primitive.STRING:
      return "STRING";
    case FieldType_Primitive.BOOLEAN:
      return "BOOLEAN";
    case FieldType_Primitive.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FieldType_Enum {
  variants: string[];
}

/** Recursive message definition */
export interface FieldType_Array {
  elementType?: FieldType | undefined;
}

export interface UpsertSchemaRequest {
  schema?: Schema | undefined;
}

export interface UpsertSchemaResponse {
  success: boolean;
  message: string;
}

export interface GetSchemaRequest {
  name: string;
}

export interface GetSchemaResponse {
  schema?: Schema | undefined;
  found: boolean;
}

function createBaseEvent(): Event {
  return { id: "", eventType: "", payload: Buffer.alloc(0), timestamp: 0 };
}

export const Event = {
  encode(message: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.payload.length !== 0) {
      writer.uint32(26).bytes(message.payload);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.id = object.id ?? "";
    message.eventType = object.eventType ?? "";
    message.payload = object.payload ?? Buffer.alloc(0);
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseAppendEventRequest(): AppendEventRequest {
  return { streamId: "", events: [], expectedVersion: 0 };
}

export const AppendEventRequest = {
  encode(message: AppendEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.expectedVersion !== 0) {
      writer.uint32(24).uint64(message.expectedVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppendEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppendEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.expectedVersion = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppendEventRequest {
    return {
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
      expectedVersion: isSet(object.expectedVersion) ? globalThis.Number(object.expectedVersion) : 0,
    };
  },

  toJSON(message: AppendEventRequest): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.expectedVersion !== 0) {
      obj.expectedVersion = Math.round(message.expectedVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppendEventRequest>, I>>(base?: I): AppendEventRequest {
    return AppendEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppendEventRequest>, I>>(object: I): AppendEventRequest {
    const message = createBaseAppendEventRequest();
    message.streamId = object.streamId ?? "";
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.expectedVersion = object.expectedVersion ?? 0;
    return message;
  },
};

function createBaseAppendEventResponse(): AppendEventResponse {
  return { success: false };
}

export const AppendEventResponse = {
  encode(message: AppendEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppendEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppendEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppendEventResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AppendEventResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppendEventResponse>, I>>(base?: I): AppendEventResponse {
    return AppendEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppendEventResponse>, I>>(object: I): AppendEventResponse {
    const message = createBaseAppendEventResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetEventsRequest(): GetEventsRequest {
  return { streamId: "" };
}

export const GetEventsRequest = {
  encode(message: GetEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventsRequest {
    return { streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "" };
  },

  toJSON(message: GetEventsRequest): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventsRequest>, I>>(base?: I): GetEventsRequest {
    return GetEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventsRequest>, I>>(object: I): GetEventsRequest {
    const message = createBaseGetEventsRequest();
    message.streamId = object.streamId ?? "";
    return message;
  },
};

function createBaseSchema(): Schema {
  return { name: "", fields: {} };
}

export const Schema = {
  encode(message: Schema, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      Schema_FieldsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Schema {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Schema_FieldsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.fields[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: Field }>((acc, [key, value]) => {
          acc[key] = Field.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = Field.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schema>, I>>(base?: I): Schema {
    return Schema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schema>, I>>(object: I): Schema {
    const message = createBaseSchema();
    message.name = object.name ?? "";
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: Field }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Field.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSchema_FieldsEntry(): Schema_FieldsEntry {
  return { key: "", value: undefined };
}

export const Schema_FieldsEntry = {
  encode(message: Schema_FieldsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Field.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Schema_FieldsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Field.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Field.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Schema_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Field.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schema_FieldsEntry>, I>>(base?: I): Schema_FieldsEntry {
    return Schema_FieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schema_FieldsEntry>, I>>(object: I): Schema_FieldsEntry {
    const message = createBaseSchema_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Field.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseField(): Field {
  return { fieldType: undefined, nullable: false, overridesOnNull: false, constraints: undefined };
}

export const Field = {
  encode(message: Field, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fieldType !== undefined) {
      FieldType.encode(message.fieldType, writer.uint32(10).fork()).ldelim();
    }
    if (message.nullable !== false) {
      writer.uint32(16).bool(message.nullable);
    }
    if (message.overridesOnNull !== false) {
      writer.uint32(24).bool(message.overridesOnNull);
    }
    if (message.constraints !== undefined) {
      FieldConstraints.encode(message.constraints, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Field {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldType = FieldType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.overridesOnNull = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.constraints = FieldConstraints.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Field {
    return {
      fieldType: isSet(object.fieldType) ? FieldType.fromJSON(object.fieldType) : undefined,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      overridesOnNull: isSet(object.overridesOnNull) ? globalThis.Boolean(object.overridesOnNull) : false,
      constraints: isSet(object.constraints) ? FieldConstraints.fromJSON(object.constraints) : undefined,
    };
  },

  toJSON(message: Field): unknown {
    const obj: any = {};
    if (message.fieldType !== undefined) {
      obj.fieldType = FieldType.toJSON(message.fieldType);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.overridesOnNull !== false) {
      obj.overridesOnNull = message.overridesOnNull;
    }
    if (message.constraints !== undefined) {
      obj.constraints = FieldConstraints.toJSON(message.constraints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Field>, I>>(base?: I): Field {
    return Field.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Field>, I>>(object: I): Field {
    const message = createBaseField();
    message.fieldType = (object.fieldType !== undefined && object.fieldType !== null)
      ? FieldType.fromPartial(object.fieldType)
      : undefined;
    message.nullable = object.nullable ?? false;
    message.overridesOnNull = object.overridesOnNull ?? false;
    message.constraints = (object.constraints !== undefined && object.constraints !== null)
      ? FieldConstraints.fromPartial(object.constraints)
      : undefined;
    return message;
  },
};

function createBaseFieldConstraints(): FieldConstraints {
  return {
    required: false,
    minValue: undefined,
    maxValue: undefined,
    minLength: undefined,
    maxLength: undefined,
    regex: undefined,
  };
}

export const FieldConstraints = {
  encode(message: FieldConstraints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.required !== false) {
      writer.uint32(8).bool(message.required);
    }
    if (message.minValue !== undefined) {
      writer.uint32(17).double(message.minValue);
    }
    if (message.maxValue !== undefined) {
      writer.uint32(25).double(message.maxValue);
    }
    if (message.minLength !== undefined) {
      writer.uint32(32).int32(message.minLength);
    }
    if (message.maxLength !== undefined) {
      writer.uint32(40).int32(message.maxLength);
    }
    if (message.regex !== undefined) {
      writer.uint32(50).string(message.regex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FieldConstraints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.minValue = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.maxValue = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minLength = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxLength = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.regex = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldConstraints {
    return {
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : undefined,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : undefined,
      minLength: isSet(object.minLength) ? globalThis.Number(object.minLength) : undefined,
      maxLength: isSet(object.maxLength) ? globalThis.Number(object.maxLength) : undefined,
      regex: isSet(object.regex) ? globalThis.String(object.regex) : undefined,
    };
  },

  toJSON(message: FieldConstraints): unknown {
    const obj: any = {};
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.minValue !== undefined) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== undefined) {
      obj.maxValue = message.maxValue;
    }
    if (message.minLength !== undefined) {
      obj.minLength = Math.round(message.minLength);
    }
    if (message.maxLength !== undefined) {
      obj.maxLength = Math.round(message.maxLength);
    }
    if (message.regex !== undefined) {
      obj.regex = message.regex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldConstraints>, I>>(base?: I): FieldConstraints {
    return FieldConstraints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldConstraints>, I>>(object: I): FieldConstraints {
    const message = createBaseFieldConstraints();
    message.required = object.required ?? false;
    message.minValue = object.minValue ?? undefined;
    message.maxValue = object.maxValue ?? undefined;
    message.minLength = object.minLength ?? undefined;
    message.maxLength = object.maxLength ?? undefined;
    message.regex = object.regex ?? undefined;
    return message;
  },
};

function createBaseFieldType(): FieldType {
  return { primitive: undefined, enumDef: undefined, subSchema: undefined, arrayDef: undefined };
}

export const FieldType = {
  encode(message: FieldType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.primitive !== undefined) {
      writer.uint32(8).int32(message.primitive);
    }
    if (message.enumDef !== undefined) {
      FieldType_Enum.encode(message.enumDef, writer.uint32(18).fork()).ldelim();
    }
    if (message.subSchema !== undefined) {
      Schema.encode(message.subSchema, writer.uint32(26).fork()).ldelim();
    }
    if (message.arrayDef !== undefined) {
      FieldType_Array.encode(message.arrayDef, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FieldType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.primitive = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.enumDef = FieldType_Enum.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subSchema = Schema.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.arrayDef = FieldType_Array.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType {
    return {
      primitive: isSet(object.primitive) ? fieldType_PrimitiveFromJSON(object.primitive) : undefined,
      enumDef: isSet(object.enumDef) ? FieldType_Enum.fromJSON(object.enumDef) : undefined,
      subSchema: isSet(object.subSchema) ? Schema.fromJSON(object.subSchema) : undefined,
      arrayDef: isSet(object.arrayDef) ? FieldType_Array.fromJSON(object.arrayDef) : undefined,
    };
  },

  toJSON(message: FieldType): unknown {
    const obj: any = {};
    if (message.primitive !== undefined) {
      obj.primitive = fieldType_PrimitiveToJSON(message.primitive);
    }
    if (message.enumDef !== undefined) {
      obj.enumDef = FieldType_Enum.toJSON(message.enumDef);
    }
    if (message.subSchema !== undefined) {
      obj.subSchema = Schema.toJSON(message.subSchema);
    }
    if (message.arrayDef !== undefined) {
      obj.arrayDef = FieldType_Array.toJSON(message.arrayDef);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldType>, I>>(base?: I): FieldType {
    return FieldType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldType>, I>>(object: I): FieldType {
    const message = createBaseFieldType();
    message.primitive = object.primitive ?? undefined;
    message.enumDef = (object.enumDef !== undefined && object.enumDef !== null)
      ? FieldType_Enum.fromPartial(object.enumDef)
      : undefined;
    message.subSchema = (object.subSchema !== undefined && object.subSchema !== null)
      ? Schema.fromPartial(object.subSchema)
      : undefined;
    message.arrayDef = (object.arrayDef !== undefined && object.arrayDef !== null)
      ? FieldType_Array.fromPartial(object.arrayDef)
      : undefined;
    return message;
  },
};

function createBaseFieldType_Enum(): FieldType_Enum {
  return { variants: [] };
}

export const FieldType_Enum = {
  encode(message: FieldType_Enum, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.variants) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FieldType_Enum {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType_Enum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variants.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType_Enum {
    return {
      variants: globalThis.Array.isArray(object?.variants) ? object.variants.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: FieldType_Enum): unknown {
    const obj: any = {};
    if (message.variants?.length) {
      obj.variants = message.variants;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldType_Enum>, I>>(base?: I): FieldType_Enum {
    return FieldType_Enum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldType_Enum>, I>>(object: I): FieldType_Enum {
    const message = createBaseFieldType_Enum();
    message.variants = object.variants?.map((e) => e) || [];
    return message;
  },
};

function createBaseFieldType_Array(): FieldType_Array {
  return { elementType: undefined };
}

export const FieldType_Array = {
  encode(message: FieldType_Array, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.elementType !== undefined) {
      FieldType.encode(message.elementType, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FieldType_Array {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType_Array();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elementType = FieldType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType_Array {
    return { elementType: isSet(object.elementType) ? FieldType.fromJSON(object.elementType) : undefined };
  },

  toJSON(message: FieldType_Array): unknown {
    const obj: any = {};
    if (message.elementType !== undefined) {
      obj.elementType = FieldType.toJSON(message.elementType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldType_Array>, I>>(base?: I): FieldType_Array {
    return FieldType_Array.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldType_Array>, I>>(object: I): FieldType_Array {
    const message = createBaseFieldType_Array();
    message.elementType = (object.elementType !== undefined && object.elementType !== null)
      ? FieldType.fromPartial(object.elementType)
      : undefined;
    return message;
  },
};

function createBaseUpsertSchemaRequest(): UpsertSchemaRequest {
  return { schema: undefined };
}

export const UpsertSchemaRequest = {
  encode(message: UpsertSchemaRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpsertSchemaRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertSchemaRequest {
    return { schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined };
  },

  toJSON(message: UpsertSchemaRequest): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertSchemaRequest>, I>>(base?: I): UpsertSchemaRequest {
    return UpsertSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertSchemaRequest>, I>>(object: I): UpsertSchemaRequest {
    const message = createBaseUpsertSchemaRequest();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    return message;
  },
};

function createBaseUpsertSchemaResponse(): UpsertSchemaResponse {
  return { success: false, message: "" };
}

export const UpsertSchemaResponse = {
  encode(message: UpsertSchemaResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpsertSchemaResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertSchemaResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: UpsertSchemaResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertSchemaResponse>, I>>(base?: I): UpsertSchemaResponse {
    return UpsertSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertSchemaResponse>, I>>(object: I): UpsertSchemaResponse {
    const message = createBaseUpsertSchemaResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetSchemaRequest(): GetSchemaRequest {
  return { name: "" };
}

export const GetSchemaRequest = {
  encode(message: GetSchemaRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSchemaRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemaRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSchemaRequest>, I>>(base?: I): GetSchemaRequest {
    return GetSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSchemaRequest>, I>>(object: I): GetSchemaRequest {
    const message = createBaseGetSchemaRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetSchemaResponse(): GetSchemaResponse {
  return { schema: undefined, found: false };
}

export const GetSchemaResponse = {
  encode(message: GetSchemaResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(10).fork()).ldelim();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSchemaResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemaResponse {
    return {
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: GetSchemaResponse): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSchemaResponse>, I>>(base?: I): GetSchemaResponse {
    return GetSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSchemaResponse>, I>>(object: I): GetSchemaResponse {
    const message = createBaseGetSchemaResponse();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

export type EventStoreService = typeof EventStoreService;
export const EventStoreService = {
  appendEvent: {
    path: "/eventstore.EventStore/AppendEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AppendEventRequest) => Buffer.from(AppendEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AppendEventRequest.decode(value),
    responseSerialize: (value: AppendEventResponse) => Buffer.from(AppendEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AppendEventResponse.decode(value),
  },
  getEvents: {
    path: "/eventstore.EventStore/GetEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetEventsRequest) => Buffer.from(GetEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEventsRequest.decode(value),
    responseSerialize: (value: Event) => Buffer.from(Event.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Event.decode(value),
  },
  /** Schema Management */
  upsertSchema: {
    path: "/eventstore.EventStore/UpsertSchema",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpsertSchemaRequest) => Buffer.from(UpsertSchemaRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpsertSchemaRequest.decode(value),
    responseSerialize: (value: UpsertSchemaResponse) => Buffer.from(UpsertSchemaResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpsertSchemaResponse.decode(value),
  },
  getSchema: {
    path: "/eventstore.EventStore/GetSchema",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSchemaRequest) => Buffer.from(GetSchemaRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetSchemaRequest.decode(value),
    responseSerialize: (value: GetSchemaResponse) => Buffer.from(GetSchemaResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetSchemaResponse.decode(value),
  },
} as const;

export interface EventStoreServer extends UntypedServiceImplementation {
  appendEvent: handleUnaryCall<AppendEventRequest, AppendEventResponse>;
  getEvents: handleServerStreamingCall<GetEventsRequest, Event>;
  /** Schema Management */
  upsertSchema: handleUnaryCall<UpsertSchemaRequest, UpsertSchemaResponse>;
  getSchema: handleUnaryCall<GetSchemaRequest, GetSchemaResponse>;
}

export interface EventStoreClient extends Client {
  appendEvent(
    request: AppendEventRequest,
    callback: (error: ServiceError | null, response: AppendEventResponse) => void,
  ): ClientUnaryCall;
  appendEvent(
    request: AppendEventRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AppendEventResponse) => void,
  ): ClientUnaryCall;
  appendEvent(
    request: AppendEventRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AppendEventResponse) => void,
  ): ClientUnaryCall;
  getEvents(request: GetEventsRequest, options?: Partial<CallOptions>): ClientReadableStream<Event>;
  getEvents(
    request: GetEventsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Event>;
  /** Schema Management */
  upsertSchema(
    request: UpsertSchemaRequest,
    callback: (error: ServiceError | null, response: UpsertSchemaResponse) => void,
  ): ClientUnaryCall;
  upsertSchema(
    request: UpsertSchemaRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpsertSchemaResponse) => void,
  ): ClientUnaryCall;
  upsertSchema(
    request: UpsertSchemaRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpsertSchemaResponse) => void,
  ): ClientUnaryCall;
  getSchema(
    request: GetSchemaRequest,
    callback: (error: ServiceError | null, response: GetSchemaResponse) => void,
  ): ClientUnaryCall;
  getSchema(
    request: GetSchemaRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSchemaResponse) => void,
  ): ClientUnaryCall;
  getSchema(
    request: GetSchemaRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSchemaResponse) => void,
  ): ClientUnaryCall;
}

export const EventStoreClient = makeGenericClientConstructor(EventStoreService, "eventstore.EventStore") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): EventStoreClient;
  service: typeof EventStoreService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: eventstore.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventStoreClient = exports.EventStoreService = exports.GetSchemaResponse = exports.GetSchemaRequest = exports.UpsertSchemaResponse = exports.UpsertSchemaRequest = exports.FieldType_Array = exports.FieldType_Enum = exports.FieldType = exports.FieldConstraints = exports.Field = exports.Schema_FieldsEntry = exports.Schema = exports.GetEventsRequest = exports.AppendEventResponse = exports.AppendEventRequest = exports.Event = exports.FieldType_Primitive = exports.protobufPackage = void 0;
exports.fieldType_PrimitiveFromJSON = fieldType_PrimitiveFromJSON;
exports.fieldType_PrimitiveToJSON = fieldType_PrimitiveToJSON;
/* eslint-disable */
const grpc_js_1 = require("@grpc/grpc-js");
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "eventstore";
var FieldType_Primitive;
(function (FieldType_Primitive) {
    FieldType_Primitive[FieldType_Primitive["NUMBER"] = 0] = "NUMBER";
    FieldType_Primitive[FieldType_Primitive["STRING"] = 1] = "STRING";
    FieldType_Primitive[FieldType_Primitive["BOOLEAN"] = 2] = "BOOLEAN";
    FieldType_Primitive[FieldType_Primitive["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldType_Primitive || (exports.FieldType_Primitive = FieldType_Primitive = {}));
function fieldType_PrimitiveFromJSON(object) {
    switch (object) {
        case 0:
        case "NUMBER":
            return FieldType_Primitive.NUMBER;
        case 1:
        case "STRING":
            return FieldType_Primitive.STRING;
        case 2:
        case "BOOLEAN":
            return FieldType_Primitive.BOOLEAN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return FieldType_Primitive.UNRECOGNIZED;
    }
}
function fieldType_PrimitiveToJSON(object) {
    switch (object) {
        case FieldType_Primitive.NUMBER:
            return "NUMBER";
        case FieldType_Primitive.STRING:
            return "STRING";
        case FieldType_Primitive.BOOLEAN:
            return "BOOLEAN";
        case FieldType_Primitive.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseEvent() {
    return { id: "", eventType: "", payload: Buffer.alloc(0), timestamp: 0 };
}
exports.Event = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.eventType !== "") {
            writer.uint32(18).string(message.eventType);
        }
        if (message.payload.length !== 0) {
            writer.uint32(26).bytes(message.payload);
        }
        if (message.timestamp !== 0) {
            writer.uint32(32).uint64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.eventType = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.timestamp = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
            payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
            timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.eventType !== "") {
            obj.eventType = message.eventType;
        }
        if (message.payload.length !== 0) {
            obj.payload = base64FromBytes(message.payload);
        }
        if (message.timestamp !== 0) {
            obj.timestamp = Math.round(message.timestamp);
        }
        return obj;
    },
    create(base) {
        return exports.Event.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEvent();
        message.id = object.id ?? "";
        message.eventType = object.eventType ?? "";
        message.payload = object.payload ?? Buffer.alloc(0);
        message.timestamp = object.timestamp ?? 0;
        return message;
    },
};
function createBaseAppendEventRequest() {
    return { streamId: "", events: [], expectedVersion: 0 };
}
exports.AppendEventRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.streamId !== "") {
            writer.uint32(10).string(message.streamId);
        }
        for (const v of message.events) {
            exports.Event.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.expectedVersion !== 0) {
            writer.uint32(24).uint64(message.expectedVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppendEventRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.streamId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.events.push(exports.Event.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.expectedVersion = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
            events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => exports.Event.fromJSON(e)) : [],
            expectedVersion: isSet(object.expectedVersion) ? globalThis.Number(object.expectedVersion) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.streamId !== "") {
            obj.streamId = message.streamId;
        }
        if (message.events?.length) {
            obj.events = message.events.map((e) => exports.Event.toJSON(e));
        }
        if (message.expectedVersion !== 0) {
            obj.expectedVersion = Math.round(message.expectedVersion);
        }
        return obj;
    },
    create(base) {
        return exports.AppendEventRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppendEventRequest();
        message.streamId = object.streamId ?? "";
        message.events = object.events?.map((e) => exports.Event.fromPartial(e)) || [];
        message.expectedVersion = object.expectedVersion ?? 0;
        return message;
    },
};
function createBaseAppendEventResponse() {
    return { success: false };
}
exports.AppendEventResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppendEventResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        return obj;
    },
    create(base) {
        return exports.AppendEventResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppendEventResponse();
        message.success = object.success ?? false;
        return message;
    },
};
function createBaseGetEventsRequest() {
    return { streamId: "" };
}
exports.GetEventsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.streamId !== "") {
            writer.uint32(10).string(message.streamId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEventsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.streamId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.streamId !== "") {
            obj.streamId = message.streamId;
        }
        return obj;
    },
    create(base) {
        return exports.GetEventsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetEventsRequest();
        message.streamId = object.streamId ?? "";
        return message;
    },
};
function createBaseSchema() {
    return { name: "", fields: {} };
}
exports.Schema = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.fields).forEach(([key, value]) => {
            exports.Schema_FieldsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.Schema_FieldsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.fields[entry2.key] = entry2.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            fields: isObject(object.fields)
                ? Object.entries(object.fields).reduce((acc, [key, value]) => {
                    acc[key] = exports.Field.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.fields) {
            const entries = Object.entries(message.fields);
            if (entries.length > 0) {
                obj.fields = {};
                entries.forEach(([k, v]) => {
                    obj.fields[k] = exports.Field.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.Schema.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchema();
        message.name = object.name ?? "";
        message.fields = Object.entries(object.fields ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.Field.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSchema_FieldsEntry() {
    return { key: "", value: undefined };
}
exports.Schema_FieldsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Field.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchema_FieldsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.Field.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? exports.Field.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = exports.Field.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.Schema_FieldsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchema_FieldsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null) ? exports.Field.fromPartial(object.value) : undefined;
        return message;
    },
};
function createBaseField() {
    return { fieldType: undefined, nullable: false, overridesOnNull: false, constraints: undefined };
}
exports.Field = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fieldType !== undefined) {
            exports.FieldType.encode(message.fieldType, writer.uint32(10).fork()).ldelim();
        }
        if (message.nullable !== false) {
            writer.uint32(16).bool(message.nullable);
        }
        if (message.overridesOnNull !== false) {
            writer.uint32(24).bool(message.overridesOnNull);
        }
        if (message.constraints !== undefined) {
            exports.FieldConstraints.encode(message.constraints, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseField();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fieldType = exports.FieldType.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.nullable = reader.bool();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.overridesOnNull = reader.bool();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.constraints = exports.FieldConstraints.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            fieldType: isSet(object.fieldType) ? exports.FieldType.fromJSON(object.fieldType) : undefined,
            nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
            overridesOnNull: isSet(object.overridesOnNull) ? globalThis.Boolean(object.overridesOnNull) : false,
            constraints: isSet(object.constraints) ? exports.FieldConstraints.fromJSON(object.constraints) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fieldType !== undefined) {
            obj.fieldType = exports.FieldType.toJSON(message.fieldType);
        }
        if (message.nullable !== false) {
            obj.nullable = message.nullable;
        }
        if (message.overridesOnNull !== false) {
            obj.overridesOnNull = message.overridesOnNull;
        }
        if (message.constraints !== undefined) {
            obj.constraints = exports.FieldConstraints.toJSON(message.constraints);
        }
        return obj;
    },
    create(base) {
        return exports.Field.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseField();
        message.fieldType = (object.fieldType !== undefined && object.fieldType !== null)
            ? exports.FieldType.fromPartial(object.fieldType)
            : undefined;
        message.nullable = object.nullable ?? false;
        message.overridesOnNull = object.overridesOnNull ?? false;
        message.constraints = (object.constraints !== undefined && object.constraints !== null)
            ? exports.FieldConstraints.fromPartial(object.constraints)
            : undefined;
        return message;
    },
};
function createBaseFieldConstraints() {
    return {
        required: false,
        minValue: undefined,
        maxValue: undefined,
        minLength: undefined,
        maxLength: undefined,
        regex: undefined,
    };
}
exports.FieldConstraints = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.required !== false) {
            writer.uint32(8).bool(message.required);
        }
        if (message.minValue !== undefined) {
            writer.uint32(17).double(message.minValue);
        }
        if (message.maxValue !== undefined) {
            writer.uint32(25).double(message.maxValue);
        }
        if (message.minLength !== undefined) {
            writer.uint32(32).int32(message.minLength);
        }
        if (message.maxLength !== undefined) {
            writer.uint32(40).int32(message.maxLength);
        }
        if (message.regex !== undefined) {
            writer.uint32(50).string(message.regex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFieldConstraints();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.required = reader.bool();
                    continue;
                case 2:
                    if (tag !== 17) {
                        break;
                    }
                    message.minValue = reader.double();
                    continue;
                case 3:
                    if (tag !== 25) {
                        break;
                    }
                    message.maxValue = reader.double();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.minLength = reader.int32();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.maxLength = reader.int32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.regex = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
            minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : undefined,
            maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : undefined,
            minLength: isSet(object.minLength) ? globalThis.Number(object.minLength) : undefined,
            maxLength: isSet(object.maxLength) ? globalThis.Number(object.maxLength) : undefined,
            regex: isSet(object.regex) ? globalThis.String(object.regex) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.required !== false) {
            obj.required = message.required;
        }
        if (message.minValue !== undefined) {
            obj.minValue = message.minValue;
        }
        if (message.maxValue !== undefined) {
            obj.maxValue = message.maxValue;
        }
        if (message.minLength !== undefined) {
            obj.minLength = Math.round(message.minLength);
        }
        if (message.maxLength !== undefined) {
            obj.maxLength = Math.round(message.maxLength);
        }
        if (message.regex !== undefined) {
            obj.regex = message.regex;
        }
        return obj;
    },
    create(base) {
        return exports.FieldConstraints.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFieldConstraints();
        message.required = object.required ?? false;
        message.minValue = object.minValue ?? undefined;
        message.maxValue = object.maxValue ?? undefined;
        message.minLength = object.minLength ?? undefined;
        message.maxLength = object.maxLength ?? undefined;
        message.regex = object.regex ?? undefined;
        return message;
    },
};
function createBaseFieldType() {
    return { primitive: undefined, enumDef: undefined, subSchema: undefined, arrayDef: undefined };
}
exports.FieldType = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.primitive !== undefined) {
            writer.uint32(8).int32(message.primitive);
        }
        if (message.enumDef !== undefined) {
            exports.FieldType_Enum.encode(message.enumDef, writer.uint32(18).fork()).ldelim();
        }
        if (message.subSchema !== undefined) {
            exports.Schema.encode(message.subSchema, writer.uint32(26).fork()).ldelim();
        }
        if (message.arrayDef !== undefined) {
            exports.FieldType_Array.encode(message.arrayDef, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFieldType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.primitive = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.enumDef = exports.FieldType_Enum.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.subSchema = exports.Schema.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.arrayDef = exports.FieldType_Array.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            primitive: isSet(object.primitive) ? fieldType_PrimitiveFromJSON(object.primitive) : undefined,
            enumDef: isSet(object.enumDef) ? exports.FieldType_Enum.fromJSON(object.enumDef) : undefined,
            subSchema: isSet(object.subSchema) ? exports.Schema.fromJSON(object.subSchema) : undefined,
            arrayDef: isSet(object.arrayDef) ? exports.FieldType_Array.fromJSON(object.arrayDef) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.primitive !== undefined) {
            obj.primitive = fieldType_PrimitiveToJSON(message.primitive);
        }
        if (message.enumDef !== undefined) {
            obj.enumDef = exports.FieldType_Enum.toJSON(message.enumDef);
        }
        if (message.subSchema !== undefined) {
            obj.subSchema = exports.Schema.toJSON(message.subSchema);
        }
        if (message.arrayDef !== undefined) {
            obj.arrayDef = exports.FieldType_Array.toJSON(message.arrayDef);
        }
        return obj;
    },
    create(base) {
        return exports.FieldType.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFieldType();
        message.primitive = object.primitive ?? undefined;
        message.enumDef = (object.enumDef !== undefined && object.enumDef !== null)
            ? exports.FieldType_Enum.fromPartial(object.enumDef)
            : undefined;
        message.subSchema = (object.subSchema !== undefined && object.subSchema !== null)
            ? exports.Schema.fromPartial(object.subSchema)
            : undefined;
        message.arrayDef = (object.arrayDef !== undefined && object.arrayDef !== null)
            ? exports.FieldType_Array.fromPartial(object.arrayDef)
            : undefined;
        return message;
    },
};
function createBaseFieldType_Enum() {
    return { variants: [] };
}
exports.FieldType_Enum = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.variants) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFieldType_Enum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.variants.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            variants: globalThis.Array.isArray(object?.variants) ? object.variants.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.variants?.length) {
            obj.variants = message.variants;
        }
        return obj;
    },
    create(base) {
        return exports.FieldType_Enum.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFieldType_Enum();
        message.variants = object.variants?.map((e) => e) || [];
        return message;
    },
};
function createBaseFieldType_Array() {
    return { elementType: undefined };
}
exports.FieldType_Array = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.elementType !== undefined) {
            exports.FieldType.encode(message.elementType, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFieldType_Array();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.elementType = exports.FieldType.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { elementType: isSet(object.elementType) ? exports.FieldType.fromJSON(object.elementType) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.elementType !== undefined) {
            obj.elementType = exports.FieldType.toJSON(message.elementType);
        }
        return obj;
    },
    create(base) {
        return exports.FieldType_Array.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFieldType_Array();
        message.elementType = (object.elementType !== undefined && object.elementType !== null)
            ? exports.FieldType.fromPartial(object.elementType)
            : undefined;
        return message;
    },
};
function createBaseUpsertSchemaRequest() {
    return { schema: undefined };
}
exports.UpsertSchemaRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.schema !== undefined) {
            exports.Schema.encode(message.schema, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpsertSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.schema = exports.Schema.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { schema: isSet(object.schema) ? exports.Schema.fromJSON(object.schema) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.schema !== undefined) {
            obj.schema = exports.Schema.toJSON(message.schema);
        }
        return obj;
    },
    create(base) {
        return exports.UpsertSchemaRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpsertSchemaRequest();
        message.schema = (object.schema !== undefined && object.schema !== null)
            ? exports.Schema.fromPartial(object.schema)
            : undefined;
        return message;
    },
};
function createBaseUpsertSchemaResponse() {
    return { success: false, message: "" };
}
exports.UpsertSchemaResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpsertSchemaResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            message: isSet(object.message) ? globalThis.String(object.message) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return exports.UpsertSchemaResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpsertSchemaResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? "";
        return message;
    },
};
function createBaseGetSchemaRequest() {
    return { name: "" };
}
exports.GetSchemaRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return exports.GetSchemaRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSchemaRequest();
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseGetSchemaResponse() {
    return { schema: undefined, found: false };
}
exports.GetSchemaResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.schema !== undefined) {
            exports.Schema.encode(message.schema, writer.uint32(10).fork()).ldelim();
        }
        if (message.found !== false) {
            writer.uint32(16).bool(message.found);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSchemaResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.schema = exports.Schema.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.found = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            schema: isSet(object.schema) ? exports.Schema.fromJSON(object.schema) : undefined,
            found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.schema !== undefined) {
            obj.schema = exports.Schema.toJSON(message.schema);
        }
        if (message.found !== false) {
            obj.found = message.found;
        }
        return obj;
    },
    create(base) {
        return exports.GetSchemaResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSchemaResponse();
        message.schema = (object.schema !== undefined && object.schema !== null)
            ? exports.Schema.fromPartial(object.schema)
            : undefined;
        message.found = object.found ?? false;
        return message;
    },
};
exports.EventStoreService = {
    appendEvent: {
        path: "/eventstore.EventStore/AppendEvent",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.AppendEventRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.AppendEventRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.AppendEventResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.AppendEventResponse.decode(value),
    },
    getEvents: {
        path: "/eventstore.EventStore/GetEvents",
        requestStream: false,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(exports.GetEventsRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.GetEventsRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.Event.encode(value).finish()),
        responseDeserialize: (value) => exports.Event.decode(value),
    },
    /** Schema Management */
    upsertSchema: {
        path: "/eventstore.EventStore/UpsertSchema",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.UpsertSchemaRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.UpsertSchemaRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.UpsertSchemaResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.UpsertSchemaResponse.decode(value),
    },
    getSchema: {
        path: "/eventstore.EventStore/GetSchema",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.GetSchemaRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.GetSchemaRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.GetSchemaResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.GetSchemaResponse.decode(value),
    },
};
exports.EventStoreClient = (0, grpc_js_1.makeGenericClientConstructor)(exports.EventStoreService, "eventstore.EventStore");
function bytesFromBase64(b64) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}
function base64FromBytes(arr) {
    return globalThis.Buffer.from(arr).toString("base64");
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
